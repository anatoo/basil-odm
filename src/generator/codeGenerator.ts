import { FieldsSchemaRoot, Enum } from '../schema/astTypes';
import { CollectionDef, DefinedSchema } from '../types';
import { writeFileSync } from 'fs';
import { prettier } from '../utils';
import { aggregateEnums, generateDefaultValue, generateType, getDefaultEntityName } from './utils';
import { inspect } from 'util';

export const header = `/**
 * This file was generated by Basil ODM
 * Do not make changes to this file directly
 */
/* eslint-disable */
import * as mongodb from 'mongodb';
import * as basil from 'basil-odm';

`;

export function generateEnumsCode(collections: CollectionDef[]): string {
  let code = '';

  let enums = collections.flatMap((collection) => {
    const root = collection.schema.getSchemaAST();
    return aggregateEnums(root);
  });

  // remove duplicated
  const enumsMap = new Map<string, Enum>();
  for (const node of enums) {
    if (typeof node.name === 'string') {
      if (enumsMap.has(node.name)) {
        const storedNode = enumsMap.get(node.name) as Enum;
        if (storedNode !== node && JSON.stringify(storedNode) !== JSON.stringify(node)) {
          throw Error(`These enums node has same name but different object: ${inspect(node)} ${inspect(storedNode)}`);
        }
      } else {
        enumsMap.set(node.name, node);
      }
    }
  }

  enums = [...enumsMap.values(), ...enums.filter((node) => typeof node.name !== 'string')];

  for (const node of enums) {
    if (node.name) {
      code += `export const ${node.name} = {`;
      for (const [key, value] of Object.entries(node.values)) {
        code += `${JSON.stringify(key)}: ${JSON.stringify(value)},`;
      }
      code += `} as const;\n`;

      code += `export type ${node.name} = typeof ${node.name}[keyof typeof ${node.name}];\n\n`;
    }
  }

  return code;
}

export function generateTypeScriptFile(collections: CollectionDef[]): string {
  return header + generateCollectionDefs(collections) + generateDocumentTypes(collections) + generateEnumsCode(collections);
}

export function generateCollectionDefs(collections: CollectionDef[]): string {
  let code = '';

  code += `const $defs: Record<string, basil.EntityMeta<Record<string, unknown>>> = {`;
  for (const collection of collections) {
    code += `
${JSON.stringify(collection.collectionName)}: {
  collectionName: ${JSON.stringify(collection.collectionName)},
  schema: new basil.FieldsSchema(${JSON.stringify(collection.schema.getSchemaAST())}),
  indexes: ${JSON.stringify(collection.indexes)},
},`;
  }
  code += `};\n\n`;

  return code;
}

export function generateDocumentTypes(collections: CollectionDef[]): string {
  let code = ``;

  for (const collection of collections) {
    const ast = collection.schema.getSchemaAST();
    const name = collection.entityName ?? getDefaultEntityName(collection.collectionName);

    code += `export class ${name} extends basil.Base {
constructor(params?: Partial<${name}>) {
  super();
  Object.assign(this, params);
}
static getCollection() {
  return {
    collectionName: ${JSON.stringify(collection.collectionName)},
    schema: $defs[${JSON.stringify(collection.collectionName)}].schema,
    indexes: $defs[${JSON.stringify(collection.collectionName)}].indexes,
  };
}`;

    for (const [name, field] of Object.entries(ast.props)) {
      code += `${name}${field.isOptional ? '?' : ''}: ${generateType(field.node)}`;
      if (!field.isOptional) {
        code += '= ' + generateDefaultValue(field.node);
      }
      code += ';\n';
    }

    code += '}\n\n';
  }

  return code;
}

export function generateTypeFromSchema(root: FieldsSchemaRoot) {
  return generateType(root);
}

interface GenerateCodeParams {
  outputFile: string;
  schema: DefinedSchema;
}

export function generateCode(params: GenerateCodeParams) {
  const { schema, outputFile } = params;
  const collections = Object.values(schema);
  writeFileSync(outputFile, prettier(generateTypeScriptFile(collections)));
}
