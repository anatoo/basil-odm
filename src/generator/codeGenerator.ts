import { SchemaRoot } from "../schema/astTypes";
import { CollectionDef } from "../types";
import { writeFileSync } from "fs";
import { prettier } from "../utils";
import {
  generateDefaultValue,
  generateType,
  getDefaultEntityName,
} from "./utils";

export const header = `/**
 * This file was generated by Basil ODM
 * Do not make changes to this file directly
 */
/* eslint-disable */
import * as mongodb from 'mongodb';
import * as basil from 'basil-odm';

`;

export function generateTypeScriptFile(collections: CollectionDef[]): string {
  return header + generateCollectionDefs(collections) +
    generateDocumentTypes(collections);
}

export function generateCollectionDefs(collections: CollectionDef[]): string {
  let code = "";

  code += `const $defs: Record<string, basil.TargetCollection<{}>> = {`;
  for (const collection of collections) {
    code += `
${JSON.stringify(collection.collectionName)}: {
  collectionName: ${JSON.stringify(collection.collectionName)},
  schema: new basil.FieldsSchema(${
      JSON.stringify(collection.schema.getSchemaAST())
    }),
  indexes: ${JSON.stringify(collection.indexes)},
},`;
  }
  code += `};\n\n`;

  return code;
}

export function generateDocumentTypes(collections: CollectionDef[]): string {
  let code = ``;

  for (const collection of collections) {
    const ast = collection.schema.getSchemaAST();
    const name = collection.entityName ??
      getDefaultEntityName(collection.collectionName);

    code += `export class ${name} extends basil.Base {
constructor(params?: Partial<${name}>) {
  super();
  Object.assign(this, params);
}
static getCollection() {
  return {
    collectionName: ${JSON.stringify(collection.collectionName)},
    schema: $defs[${JSON.stringify(collection.collectionName)}].schema,
    indexes: $defs[${JSON.stringify(collection.collectionName)}].indexes,
  };
}`;

    for (const [name, field] of Object.entries(ast.props)) {
      code += `${name}${field.isOptional ? "?" : ""}: ${
        generateType(field.node)
      }`;
      if (!field.isOptional) {
        code += "= " + generateDefaultValue(field.node);
      }
      code += ";\n";
    }

    code += "}\n\n";
  }

  return code;
}

export function generateTypeFromSchema(root: SchemaRoot) {
  return generateType(root);
}

interface GenerateCodeParams {
  collections: CollectionDef[];
  outputFile: string;
}

export function generateCode(params: GenerateCodeParams) {
  const { collections, outputFile } = params;
  writeFileSync(outputFile, prettier(generateTypeScriptFile(collections)));
}
